#!/bin/bash

OMARCHY_LOGO='                 ▄▄▄                                                   
 ▄█████▄    ▄███████████▄    ▄███████   ▄███████   ▄███████   ▄█   █▄    ▄█   █▄ 
███   ███  ███   ███   ███  ███   ███  ███   ███  ███   ███  ███   ███  ███   ███
███   ███  ███   ███   ███  ███   ███  ███   ███  ███   █▀   ███   ███  ███   ███
███   ███  ███   ███   ███ ▄███▄▄▄███ ▄███▄▄▄██▀  ███       ▄███▄▄▄███▄ ███▄▄▄███
███   ███  ███   ███   ███ ▀███▀▀▀███ ▀███▀▀▀▀    ███      ▀▀███▀▀▀███  ▀▀▀▀▀▀███
███   ███  ███   ███   ███  ███   ███ ██████████  ███   █▄   ███   ███  ▄██   ███
███   ███  ███   ███   ███  ███   ███  ███   ███  ███   ███  ███   ███  ███   ███
 ▀█████▀    ▀█   ███   █▀   ███   █▀   ███   ███  ███████▀   ███   █▀    ▀█████▀ 
                                       ███   █▀                                  '

# Install prerequisites
if ! command -v gum >/dev/null || ! command -v iwctl >/dev/null; then
  sudo pacman -Sy --noconfirm --needed gum iw
fi

if ! command -v tzupdate >/dev/null; then
  yay -Sy --noconfirm tzupdate
fi

abort() {
  echo "${1:-Aborted installation}"
  exit 1
}

working_network() {
  sleep ${1:-3}
  ping -c5 -W1 1.1.1.1 | grep -q "bytes from"
}

clear_logo() {
  clear
  echo -e "$OMARCHY_LOGO\n"
  echo
}

step() {
  clear_logo
  echo "$1"
  echo
}

notice() {
  clear_logo
  gum spin --spinner "globe" --title "$1" -- sleep "${2:-2}"
}

# STEP 1: NETWORK (OPTIONAL WHEN RUNNING OFFLINE INSTALLATION)

if [[ -z $NETWORK_NOT_NEEDED ]]; then
  step "Detecting network..."

  if [[ -n $WIFI_NEEDED ]] || ! working_network; then
    wifi_interfaces=$(iw dev | awk '$1=="Interface"{print $2}')
    wifi_count=$(echo "$wifi_interfaces" | wc -l)

    if [[ $wifi_count -eq 0 ]]; then
      abort "No Wi-Fi interfaces found."
    elif [[ $wifi_count -eq 1 ]]; then
      wifi_interface="$wifi_interfaces"
    else
      clear_logo
      wifi_interface=$(echo "$wifi_interfaces" | gum choose --header "Select Wi-Fi interface") || abort
    fi

    step "Scanning Wi-Fi..."
    iw_network_scan=$(sudo iw dev "$wifi_interface" scan)
    if networks=$(echo "$iw_network_scan" | sed -n 's/^[[:space:]]*SSID: //p' | sed '/^$/d' | sort -u); then
      while true; do
        clear_logo
        ssid="$(echo "$networks" | gum choose --header "Select Wi-Fi network")" || abort

        step "Connecting to $ssid..."
        if iwctl station "$wifi_interface" connect "$ssid" && working_network 5; then
          break
        else
          notice "Couldn't connect to network (bad password?)" 1
        fi
      done
    else
      notice "Couldn't find any Wi-Fi networks." 1
    fi
  fi
fi

# STEP 2: USER

user_form() {
  step "Let's setup your machine..."

  while true; do
    user_name=$(gum input --placeholder "Alphanumeric without spaces (like dhh)" --prompt.foreground="#845DF9" --prompt "User name> ") || abort

    if [[ "$user_name" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]]; then
      break
    else
      notice "User name must be alphanumeric with no spaces" 1
    fi
  done

  while true; do
    password=$(gum input --placeholder "Used for user + root + encryption" --prompt.foreground="#845DF9" --password --prompt "Password> ") || abort
    password_confirmation=$(gum input --placeholder "Must match the password you just typed" --prompt.foreground="#845DF9" --password --prompt "Confirm> ") || abort

    if [[ "$password" == "$password_confirmation" ]]; then
      break
    else
      notice "Passwords didn't match!" 1
    fi
  done

  # Hash the password using yescrypt
  password_hash=$(openssl passwd -6 "$password")

  full_name=$(gum input --placeholder "Used for git authentication (hit return to skip)" --prompt.foreground="#845DF9" --prompt "Full name> ")
  email_address=$(gum input --placeholder "Used for git authentication (hit return to skip)" --prompt.foreground="#845DF9" --prompt "Email address> ")

  while true; do
    hostname=$(gum input --placeholder "Alphanumeric without spaces (or return for 'omarchy')" --prompt.foreground="#845DF9" --prompt "Hostname> ")

    if [[ "$hostname" =~ ^[a-z_][a-z0-9_-]*[$]?$ ]]; then
      break
    else
      hostname="omarchy"
      break
    fi
  done

  # Pick timezone
  if command -v tzupdate >/dev/null; then
    geo_guessed_timezone=$(tzupdate -p)
    timezone=$(timedatectl list-timezones | gum choose --height 10 --selected "$geo_guessed_timezone" --header "Timezone") || abort
  else
    timezone=$(timedatectl list-timezones | gum filter --height 10 --header "Timezone") || abort
  fi

  # Pick keyboard layout
  keyboards=$'Albanian|al\nAmharic|et\nArmenian|am\nArabic|ara\nArabic (Egypt)|eg\nArabic (Iraq)|iq\nArabic (Morocco)|ma\nArabic (Syria)|sy\nAzerbaijani|az\nBambara|ml\nBangla|bd\nBelarusian|by\nBelgian|be\nBerber (Algeria, Latin)|dz\nBosnian|ba\nBraille|brai\nBulgarian|bg\nBurmese|mm\nChinese|cn\nCroatian|hr\nCzech|cz\nDanish|dk\nDari|af\nDhivehi|mv\nDutch|nl\nDzongkha|bt\nEnglish (Australia)|au\nEnglish (Cameroon)|cm\nEnglish (Ghana)|gh\nEnglish (New Zealand)|nz\nEnglish (Nigeria)|ng\nEnglish (South Africa)|za\nEnglish (UK)|gb\nEnglish (US)|us\nEsperanto|epo\nEstonian|ee\nFaroese|fo\nFilipino|ph\nFinnish|fi\nFrench|fr\nFrench (Canada)|ca\nFrench (Democratic Republic of the Congo)|cd\nFrench (Togo)|tg\nGeorgian|ge\nGerman|de\nGerman (Austria)|at\nGerman (Switzerland)|ch\nGreek|gr\nHebrew|il\nHungarian|hu\nIcelandic|is\nIndian|in\nIndonesian (Latin)|id\nIrish|ie\nItalian|it\nJapanese|jp\nKazakh|kz\nKhmer (Cambodia)|kh\nKorean|kr\nKyrgyz|kg\nLao|la\nLatvian|lv\nLithuanian|lt\nMacedonian|mk\nMalay (Jawi, Arabic Keyboard)|my\nMaltese|mt\nMoldavian|md\nMongolian|mn\nMontenegrin|me\nNepali|np\nNKo (AZERTY)|gn\nNorwegian|no\nPersian|ir\nPolish|pl\nPortuguese|pt\nPortuguese (Brazil)|br\nRomanian|ro\nRussian|ru\nSerbian|rs\nSinhala (phonetic)|lk\nSlovak|sk\nSlovenian|si\nSpanish|es\nSpanish (Latin American)|latam\nSwahili (Kenya)|ke\nSwahili (Tanzania)|tz\nSwedish|se\nTaiwanese|tw\nTajik|tj\nThai|th\nTswana|bw\nTurkmen|tm\nTurkish|tr\nUkrainian|ua\nUrdu (Pakistan)|pk\nUzbek|uz\nVietnamese|vn\nWolof|sn'
  keyboard=$(
    choice=$(printf '%s\n' "$keyboards" | cut -d'|' -f1 |
      gum choose --height 10 --selected "English (US)" --header "Keyboard layout") || abort
    printf '%s\n' "$keyboards" | awk -F'|' -v c="$choice" '$1==c{print $2; exit}'
  )
}

user_form

while true; do
  echo -e "Field,Value
User name,$user_name
Password,$(printf "%${#password}s" | tr ' ' '*')
Full name,${full_name:-[Skipped]}
Email address,${email_address:-[Skipped]}
Hostname,$hostname
Timezone,$timezone
Keyboard,$keyboard" |
    gum table -s "," -p

  echo
  if gum confirm --negative "No, change it" "Does this look right?"; then
    break
  else
    user_form
  fi
done

# STEP 3: DISK

get_disk_info() {
  local device="$1"
  local size model mounted partitions
  
  # Get basic disk information
  size=$(lsblk -dno SIZE "$device" 2>/dev/null)
  model=$(lsblk -dno MODEL "$device" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
  
  # Check if disk has mounted partitions
  mounted=$(lsblk -no MOUNTPOINT "$device" 2>/dev/null | grep -v '^$' | wc -l)
  
  # Count partitions
  partitions=$(lsblk -no NAME "$device" 2>/dev/null | tail -n +2 | wc -l)
  
  # Format display string
  local display="$device"
  [[ -n "$size" ]] && display="$display ($size)"
  [[ -n "$model" ]] && display="$display - $model"
  
  if [[ "$mounted" -gt 0 ]]; then
    display="$display [MOUNTED]"
  elif [[ "$partitions" -gt 0 ]]; then
    display="$display [$partitions partitions]"
  else
    display="$display [Empty]"
  fi
  
  echo "$display"
}

disk_form() {
  step "Let's select where to install Omarchy..."

  # Get available disks and format them with info
  local disk_options=""
  while IFS= read -r device; do
    if [[ -n "$device" ]]; then
      disk_info=$(get_disk_info "$device")
      disk_options="$disk_options$disk_info"$'\n'
    fi
  done < <(lsblk -dpno NAME,TYPE | grep -E '/dev/(sd|hd|vd|nvme|mmcblk)' | awk '{print $1}')
  
  selected_display=$(echo "$disk_options" | gum choose --header "Select install disk") || abort
  disk=$(echo "$selected_display" | awk '{print $1}')
}

disk_form

while true; do
  echo -e "Everything will be overwritten. There is no recovery possible."

  echo
  if gum confirm --affirmative "Yes, format disk" --negative "No, change it" "Confirm overwriting ${disk}"; then
    break
  else
    disk_form
  fi
done

clear

# Save user full name and email address, so the autostart can
# set them as OMARCHY_USER_NAME and OMARCHY_USER_EMAIL
echo "$full_name" >user_full_name.txt
echo "$email_address" >user_email_address.txt

disk_size=$(lsblk -bdno SIZE "$disk")
mib=$((1024 * 1024))
gib=$((mib * 1024))
disk_size_in_mib=$((disk_size / mib * mib)) # Rounds to nearest MiB

gpt_backup_reserve=$((mib))
boot_partition_start=$((mib))
boot_partition_size=$((2 * gib))

main_partition_start=$((boot_partition_size + boot_partition_start))
main_partition_size=$((disk_size_in_mib - main_partition_start - gpt_backup_reserve))

cat <<-_EOF_ | tee user_credentials.json >/dev/null
{
    "encryption_password": "$password",
    "root_enc_password": "$password_hash",
    "users": [
        {
            "enc_password": "$password_hash",
            "groups": [],
            "sudo": true,
            "username": "$user_name"
        }
    ]
}
_EOF_

cat <<-_EOF_ | tee user_configuration.json >/dev/null
{
    "app_config": null,
    "archinstall-language": "English",
    "auth_config": {},
    "audio_config": { "audio": "pipewire" },
    "bootloader": "Limine",
    "custom_commands": [],
    "disk_config": {
        "btrfs_options": { 
          "snapshot_config": {
            "type": "Snapper"
          }
        },
        "config_type": "default_layout",
        "device_modifications": [
            {
                "device": "$disk",
                "partitions": [
                    {
                        "btrfs": [],
                        "dev_path": null,
                        "flags": [ "boot", "esp" ],
                        "fs_type": "fat32",
                        "mount_options": [],
                        "mountpoint": "/boot",
                        "obj_id": "ea21d3f2-82bb-49cc-ab5d-6f81ae94e18d",
                        "size": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $boot_partition_size
                        },
                        "start": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $boot_partition_start
                        },
                        "status": "create",
                        "type": "primary"
                    },
                    {
                        "btrfs": [
                            { "mountpoint": "/", "name": "@" },
                            { "mountpoint": "/home", "name": "@home" },
                            { "mountpoint": "/var/log", "name": "@log" },
                            { "mountpoint": "/var/cache/pacman/pkg", "name": "@pkg" }
                        ],
                        "dev_path": null,
                        "flags": [],
                        "fs_type": "btrfs",
                        "mount_options": [ "compress=zstd" ],
                        "mountpoint": null,
                        "obj_id": "8c2c2b92-1070-455d-b76a-56263bab24aa",
                        "size": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $main_partition_size
                        },
                        "start": {
                            "sector_size": { "unit": "B", "value": 512 },
                            "unit": "B",
                            "value": $main_partition_start
                        },
                        "status": "create",
                        "type": "primary"
                    }
                ],
                "wipe": true
            }
        ],
        "disk_encryption": {
            "encryption_type": "luks",
            "lvm_volumes": [],
            "partitions": [ "8c2c2b92-1070-455d-b76a-56263bab24aa" ],
            "encryption_password": "$password"
        }
    },
    "hostname": "$hostname",
    "kernels": [ "linux" ],
    "network_config": { "type": "iso" },
    "ntp": true,
    "parallel_downloads": 8,
    "script": null,
    "services": [],
    "swap": true,
    "timezone": "$timezone",
    "locale_config": {
        "kb_layout": "$keyboard",
        "sys_enc": "UTF-8",
        "sys_lang": "en_US.UTF-8"
    },
    "mirror_config": {
        "custom_repositories": [],
        "custom_servers": [{"url": "https://geo.mirror.pkgbuild.com/\$repo/os/\$arch"}],
        "mirror_regions": {},
        "optional_repositories": []
    },
    "packages": [
        "base-devel"
    ],
    "profile_config": {
        "gfx_driver": null,
        "greeter": null,
        "profile": {}
    },
    "version": "3.0.9"
}
_EOF_
